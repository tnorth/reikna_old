

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial: advanced topics &mdash; tigger 0.2.0dev-470e334 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2.0dev-470e334',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="tigger 0.2.0dev-470e334 documentation" href="index.html" />
    <link rel="next" title="API reference" href="api/index.html" />
    <link rel="prev" title="Tutorial: basics" href="tutorial-basic.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/index.html" title="API reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial-basic.html" title="Tutorial: basics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">tigger 0.2.0dev-470e334 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial-advanced-topics">
<span id="tutorial-advanced"></span><h1>Tutorial: advanced topics<a class="headerlink" href="#tutorial-advanced-topics" title="Permalink to this headline">¶</a></h1>
<p>This tutorial goes into more detail about the internals of computations and transformations, describing how to write them.</p>
<div class="section" id="mako-basics">
<h2>Mako basics<a class="headerlink" href="#mako-basics" title="Permalink to this headline">¶</a></h2>
<p>Tigger uses <a class="reference external" href="http://makotemplates.org">Mako</a> extensively as a templating engine for transformations and computations.
For the purpose of this tutorial you only need to know several things about the synthax:</p>
<ul class="simple">
<li>Most of Mako synthax is plain Python, with the set of global variables specified externally by the code doing the template rendering</li>
<li><tt class="docutils literal"><span class="pre">${expr}</span></tt> evaluates Python expression <tt class="docutils literal"><span class="pre">expr</span></tt>, calls <tt class="docutils literal"><span class="pre">str()</span></tt> on the result and puts it into the text</li>
<li>a pair of <tt class="docutils literal"><span class="pre">&lt;%</span></tt> and <tt class="docutils literal"><span class="pre">%&gt;</span></tt> executes Python code inside, which may introduce some local variables</li>
<li>a pair of <tt class="docutils literal"><span class="pre">&lt;%def</span> <span class="pre">name=&quot;func(a,</span> <span class="pre">b)&quot;&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;/%def&gt;</span></tt> defines a template function, which actually becomes a Python function which can be called as <tt class="docutils literal"><span class="pre">func(a,</span> <span class="pre">b)</span></tt> from the other part of the template and returns a rendered string</li>
</ul>
</div>
<div class="section" id="writing-a-transformation">
<span id="tutorial-advanced-transformation"></span><h2>Writing a transformation<a class="headerlink" href="#writing-a-transformation" title="Permalink to this headline">¶</a></h2>
<p>Some common transformations are already available from <a class="reference internal" href="api/transformations.html#module-tigger.transformations" title="tigger.transformations"><tt class="xref py py-mod docutils literal"><span class="pre">transformations</span></tt></a> module.
But you can create a custom one if you need to.
Transformations are based on the class <a class="reference internal" href="api/core.html#tigger.core.Transformation" title="tigger.core.Transformation"><tt class="xref py py-class docutils literal"><span class="pre">Transformation</span></tt></a>.
Its constructor has three major groups of parameters.</p>
<p>First, <tt class="docutils literal"><span class="pre">outputs</span></tt>, <tt class="docutils literal"><span class="pre">inputs</span></tt> and <tt class="docutils literal"><span class="pre">scalars</span></tt> specify how many arguments of corresponding type the transformation take.</p>
<p>Second, <tt class="docutils literal"><span class="pre">derive_o_from_is</span></tt> and <tt class="docutils literal"><span class="pre">derive_i_from_os</span></tt> options take functions that perform type derivation.
This happens when <tt class="docutils literal"><span class="pre">prepare_for</span></tt> is called; first function will be used to propagate types from leaf inputs to base inputs, and the second one to propagate type from leaf outputs to base outputs.
If the transformation has more than one output or more than one input, and, therefore, cannot be connected to the output or input argument, respectively, the corresponding function should not be supplied.
On the other hand, if the function is not supplied, but is required, the fallback is the <a class="reference internal" href="api/cluda.html#tigger.cluda.dtypes.result_type" title="tigger.cluda.dtypes.result_type"><tt class="xref py py-func docutils literal"><span class="pre">result_type()</span></tt></a>.</p>
<p>The format of required functions is the following (here <tt class="docutils literal"><span class="pre">iN</span></tt>, <tt class="docutils literal"><span class="pre">oN</span></tt> and <tt class="docutils literal"><span class="pre">pN</span></tt> are <tt class="xref py py-class docutils literal"><span class="pre">numpy.dtype</span></tt> objects):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">derive_o_from_is(i1,</span> <span class="pre">...,</span> <span class="pre">p1,</span> <span class="pre">...)</span></tt>, returns the <tt class="xref py py-class docutils literal"><span class="pre">numpy.dtype</span></tt> for <tt class="docutils literal"><span class="pre">o1</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">derive_i_from_os(o1,</span> <span class="pre">...,</span> <span class="pre">p1,</span> <span class="pre">...)</span></tt>, returns the <tt class="xref py py-class docutils literal"><span class="pre">numpy.dtype</span></tt> for <tt class="docutils literal"><span class="pre">i1</span></tt>.</li>
</ul>
<p>The last part of the constructor is a <tt class="docutils literal"><span class="pre">code</span></tt> parameter.
It is a string with the Mako template which describes the transformation.
Variables <tt class="docutils literal"><span class="pre">i1</span></tt>, ..., <tt class="docutils literal"><span class="pre">o1</span></tt>, ..., <tt class="docutils literal"><span class="pre">p1</span></tt>, ... are available in the template and help specify load and store actions for inputs, outputs and parameters, and also to obtain their data types.
Each of these variables has attributes <tt class="docutils literal"><span class="pre">dtype</span></tt> (contains the <tt class="xref py py-class docutils literal"><span class="pre">numpy.dtype</span></tt>), <tt class="docutils literal"><span class="pre">ctype</span></tt> (contains a string with corresponding C type) and either one of <tt class="docutils literal"><span class="pre">load</span></tt> (for inputs), <tt class="docutils literal"><span class="pre">store</span></tt> (for outputs) and <tt class="docutils literal"><span class="pre">__str__</span></tt> (for scalar parameters).
<tt class="docutils literal"><span class="pre">${i1.load}</span></tt> can be used as a variable, and <tt class="docutils literal"><span class="pre">${o1.store}(val)</span></tt> as a function that takes one variable.
Also the <tt class="docutils literal"><span class="pre">dtypes</span></tt> variable is available in the template, providing access <a class="reference internal" href="api/cluda.html#module-tigger.cluda.dtypes" title="tigger.cluda.dtypes"><tt class="xref py py-mod docutils literal"><span class="pre">dtypes</span></tt></a> module, and <tt class="docutils literal"><span class="pre">func</span></tt> is a module-like object containing generalizations of arithmetic functions (see <a class="reference internal" href="api/cluda.html#cluda-kernel-toolbox"><em>Kernel toolbox</em></a> for details).</p>
<p>For example, for a scaling transformation with one input, one output and one parameter the code may look like:</p>
<div class="highlight-python"><pre>${o1.store}(${func.mul(i1.dtype, p1.dtype, out=o1.dtype)}(${i1.load}, ${p1}));</pre>
</div>
<p>There is a lot of stuff going on in this single line.
First, notice that the input is loaded as <tt class="docutils literal"><span class="pre">${i1.load}</span></tt>, and the parameter as <tt class="docutils literal"><span class="pre">${p1}</span></tt>.
Second, since any of the <tt class="docutils literal"><span class="pre">i1</span></tt> and <tt class="docutils literal"><span class="pre">p1</span></tt> can be complex, we had to use the generic multiplication template from the <tt class="docutils literal"><span class="pre">func</span></tt> quasi-module.
The result is passed to the output by calling <tt class="docutils literal"><span class="pre">${o1.store}</span></tt>.
If the transformation has several outputs, it will have several <tt class="docutils literal"><span class="pre">store</span></tt> statements.
Since the <tt class="docutils literal"><span class="pre">code</span></tt> parameter will be inserted into a function, you can safely create temporary variables if you need to.</p>
</div>
<div class="section" id="writing-a-computation">
<span id="tutorial-advanced-computation"></span><h2>Writing a computation<a class="headerlink" href="#writing-a-computation" title="Permalink to this headline">¶</a></h2>
<p>A computation must derive <a class="reference internal" href="api/core.html#tigger.core.Computation" title="tigger.core.Computation"><tt class="xref py py-class docutils literal"><span class="pre">Computation</span></tt></a> class and implement several methods.
As an example, let us create a computation which calculates <tt class="docutils literal"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">input1</span> <span class="pre">+</span> <span class="pre">input2</span> <span class="pre">*</span> <span class="pre">param</span></tt>.</p>
<p>Defining a class:</p>
<div class="highlight-python"><pre>import numpy

from tigger.helpers import *
from tigger.core import *

class TestComputation(Computation):</pre>
</div>
<p>Each computation class has to define the following methods:</p>
<ol class="arabic">
<li><p class="first">First, we have to specify <a class="reference internal" href="api/core.html#tigger.core.Computation._get_argnames" title="tigger.core.Computation._get_argnames"><tt class="xref py py-meth docutils literal"><span class="pre">_get_argnames()</span></tt></a> which returns argument names for the computation.
The arguments are split into three groups: outputs, inputs and scalar arguments.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_get_argnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="s">&#39;output&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s">&#39;input1&#39;</span><span class="p">,</span> <span class="s">&#39;input2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;param&#39;</span><span class="p">,)</span>
</pre></div>
</div>
<p>If you do not implement this method, you will need to implement a method that calls <a class="reference internal" href="api/core.html#tigger.core.Computation._set_argnames" title="tigger.core.Computation._set_argnames"><tt class="xref py py-meth docutils literal"><span class="pre">_set_argnames()</span></tt></a>, which will finish initialization.
When the computation object is created, this method has to be called prior to any calls to <tt class="docutils literal"><span class="pre">connect</span></tt> or <tt class="docutils literal"><span class="pre">prepare_for</span></tt>.
This is only necessary if your computation class can have different number of arguments depending on some parameters.
For an example, see the implementation of :py:class:tigger.elementwise.Elementwise`.</p>
</li>
<li><p class="first">Then you need to think about what values will constitute a basis for the computation.
Basis should contain all the information necessary to specify kernels, allocations and all other computation details.
In our case, we will force all the variables to have the same data type (although it is not necessary).
In addition we will need to add the array shape to the basis.
The method <a class="reference internal" href="api/core.html#tigger.core.Computation._get_basis_for" title="tigger.core.Computation._get_basis_for"><tt class="xref py py-meth docutils literal"><span class="pre">_get_basis_for()</span></tt></a>, gets executed when the user calls <tt class="docutils literal"><span class="pre">prepare_for</span></tt> and creates a basis based on the arguments and keywords passed to it.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_get_basis_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">output</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">input1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">input2</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">assert</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">input1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">input2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
<p>The keywords from <tt class="docutils literal"><span class="pre">prepare_for</span></tt> are passed directly to <a class="reference internal" href="api/core.html#tigger.core.Computation._get_basis_for" title="tigger.core.Computation._get_basis_for"><tt class="xref py py-meth docutils literal"><span class="pre">_get_basis_for()</span></tt></a>, but positional arguments may not be the same because of attached transformations.
Therefore <a class="reference internal" href="api/core.html#tigger.core.Computation._get_basis_for" title="tigger.core.Computation._get_basis_for"><tt class="xref py py-meth docutils literal"><span class="pre">_get_basis_for()</span></tt></a> gets instances of <a class="reference internal" href="api/core.html#tigger.core.ArrayValue" title="tigger.core.ArrayValue"><tt class="xref py py-class docutils literal"><span class="pre">ArrayValue</span></tt></a> and <a class="reference internal" href="api/core.html#tigger.core.ScalarValue" title="tigger.core.ScalarValue"><tt class="xref py py-class docutils literal"><span class="pre">ScalarValue</span></tt></a> as positional arguments.
At this stage we do not care about the actual data, only its properties, like shape and data type.</p>
</li>
<li><p class="first">Next method tells what arguments (array/scalar, data types and shapes) the prepared computation expects to get.
This method is used in some internal algorithms.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_get_argvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">output</span><span class="o">=</span><span class="n">ArrayValue</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">input1</span><span class="o">=</span><span class="n">ArrayValue</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">input2</span><span class="o">=</span><span class="n">ArrayValue</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">param</span><span class="o">=</span><span class="n">ScalarValue</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first">The last method actually specifies the actions to be done by the computation.
These include kernel calls, allocations and calls to nested computations.
The method takes three parameters: <tt class="docutils literal"><span class="pre">operations</span></tt> is a <a class="reference internal" href="api/core.html#tigger.core.operation.OperationRecorder" title="tigger.core.operation.OperationRecorder"><tt class="xref py py-class docutils literal"><span class="pre">OperationRecorder</span></tt></a> object, <tt class="docutils literal"><span class="pre">basis</span></tt> is a basis created by <a class="reference internal" href="api/core.html#tigger.core.Computation._get_basis_for" title="tigger.core.Computation._get_basis_for"><tt class="xref py py-meth docutils literal"><span class="pre">_get_basis_for()</span></tt></a>, and <tt class="docutils literal"><span class="pre">device_params</span></tt> is a <a class="reference internal" href="api/cluda.html#tigger.cluda.api.DeviceParameters" title="tigger.cluda.api.DeviceParameters"><tt class="xref py py-class docutils literal"><span class="pre">DeviceParameters</span></tt></a> object, which is used to optimize the computation for the specific device.</p>
<p>For our example we only need one action, which is the execution of an elementwise kernel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_construct_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">device_params</span><span class="p">):</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">template_from</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &lt;%def name=&#39;testcomp(k_output, k_input1, k_input2, k_param)&#39;&gt;</span>
<span class="sd">        ${kernel_definition}</span>
<span class="sd">        {</span>
<span class="sd">            VIRTUAL_SKIP_THREADS;</span>
<span class="sd">            int idx = virtual_global_flat_id();</span>
<span class="sd">            ${k_output.ctype} result = ${k_input1.load}(idx) +</span>
<span class="sd">                ${func.mul(k_input2.dtype, k_param.dtype)}(</span>
<span class="sd">                    ${k_input2.load}(idx), ${k_param});</span>
<span class="sd">            ${k_output.store}(result, idx);</span>
<span class="sd">        }</span>
<span class="sd">        &lt;/%def&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">operations</span><span class="o">.</span><span class="n">add_kernel</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="s">&#39;testcomp&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;output&#39;</span><span class="p">,</span> <span class="s">&#39;input1&#39;</span><span class="p">,</span> <span class="s">&#39;input2&#39;</span><span class="p">,</span> <span class="s">&#39;param&#39;</span><span class="p">],</span>
        <span class="n">global_size</span><span class="o">=</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">render_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>Every kernel call is based on the separate <tt class="docutils literal"><span class="pre">Mako</span></tt> template function.
The template can be specified as a string using <a class="reference internal" href="api/helpers.html#tigger.helpers.template_from" title="tigger.helpers.template_from"><tt class="xref py py-func docutils literal"><span class="pre">template_from()</span></tt></a>, or loaded as a separate file.
Usual pattern in this case is to call the template file same as the file where the computation class is defined (for example, <tt class="docutils literal"><span class="pre">testcomp.mako</span></tt> for <tt class="docutils literal"><span class="pre">testcomp.py</span></tt>), and store it in some variable on module load using <a class="reference internal" href="api/helpers.html#tigger.helpers.template_for" title="tigger.helpers.template_for"><tt class="xref py py-func docutils literal"><span class="pre">template_for()</span></tt></a> as <tt class="docutils literal"><span class="pre">TEMPLATE</span> <span class="pre">=</span> <span class="pre">template_for(__file__)</span></tt>.</p>
<p>The template function should take the same number of positional arguments as the kernel; you can view <tt class="docutils literal"><span class="pre">&lt;%def</span> <span class="pre">...</span> <span class="pre">&gt;</span></tt> part as an actual kernel definition, but with the arguments being python objects containing variable metadata.
Namely, every such object has attributes <tt class="docutils literal"><span class="pre">dtype</span></tt> and <tt class="docutils literal"><span class="pre">ctype</span></tt>, which contain <tt class="xref py py-class docutils literal"><span class="pre">numpy.dtype</span></tt> object and C type string for the corresponding argument.
Also, depending on whether the corresponding argument is an output array, an input array or a scalar parameter, the object can be used as <tt class="docutils literal"><span class="pre">${obj.store}(val,</span> <span class="pre">index)</span></tt>, <tt class="docutils literal"><span class="pre">${obj.load}(index)</span></tt> or <tt class="docutils literal"><span class="pre">${obj}</span></tt>.
This will produce corresponding request to the global memory or kernel arguments.</p>
<p>If you need additional device functions, they have to be specified between <tt class="docutils literal"><span class="pre">&lt;%def</span> <span class="pre">...</span> <span class="pre">&gt;</span></tt> and <tt class="docutils literal"><span class="pre">${kernel_definition}</span></tt> (the latter is where the actual kernel signature will be rendered).
Obviously, these functions can still use <tt class="docutils literal"><span class="pre">dtype</span></tt> and <tt class="docutils literal"><span class="pre">ctype</span></tt> object properties, although <tt class="docutils literal"><span class="pre">store</span></tt> and <tt class="docutils literal"><span class="pre">load</span></tt> will lead to unpredictable results (since they are rendered as macros using main kernel arguments).</p>
<p>Since kernel call parameters (<tt class="docutils literal"><span class="pre">global_size</span></tt> and <tt class="docutils literal"><span class="pre">local_size</span></tt>) are specified on creation, all kernel calls are rendered as CLUDA static kernels (see <a class="reference internal" href="api/cluda.html#tigger.cluda.api.Context.compile_static" title="tigger.cluda.api.Context.compile_static"><tt class="xref py py-meth docutils literal"><span class="pre">compile_static()</span></tt></a>) and therefore can use all the corresponding macros and functions (like <a class="reference internal" href="api/cluda.html#virtual_global_flat_id" title="virtual_global_flat_id"><tt class="xref c c-func docutils literal"><span class="pre">virtual_global_flat_id()</span></tt></a> in our kernel).
Also, they must have <a class="reference internal" href="api/cluda.html#VIRTUAL_SKIP_THREADS" title="VIRTUAL_SKIP_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">VIRTUAL_SKIP_THREADS</span></tt></a> at the beginning of the kernel.</p>
</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial: advanced topics</a><ul>
<li><a class="reference internal" href="#mako-basics">Mako basics</a></li>
<li><a class="reference internal" href="#writing-a-transformation">Writing a transformation</a></li>
<li><a class="reference internal" href="#writing-a-computation">Writing a computation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial-basic.html"
                        title="previous chapter">Tutorial: basics</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api/index.html"
                        title="next chapter">API reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial-advanced.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/index.html" title="API reference"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial-basic.html" title="Tutorial: basics"
             >previous</a> |</li>
        <li><a href="index.html">tigger 0.2.0dev-470e334 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Bogdan Opanchuk.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>